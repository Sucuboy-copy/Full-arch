name: Compilación Móvil (Termux & iSH)

on:
  push:
    tags:
      - 'v[0-9]+.[0-9]+.[0-9]+'
  workflow_dispatch:

jobs:
  mobile_build:
    runs-on: ubuntu-latest
    
    # Definimos la matriz para los entornos de compilación cruzada
    strategy:
      matrix:
        include:
          # 1. Termux (Android) - AArch64 (64-bit ARM)
          - target-arch: aarch64
            target-system: termux
            docker-image: ghcr.io/termux/termux-packages:master
            artifact-name: spotdl-termux-aarch64

          # 2. Termux (Android) - ARM (32-bit ARM)
          - target-arch: arm
            target-system: termux
            docker-image: ghcr.io/termux/termux-packages:master
            artifact-name: spotdl-termux-arm

          # 3. iSH (iOS) - Alpine Linux (x86 - i386)
          # NOTA: iSH emula x86_32 (i386).
          - target-arch: i386
            target-system: ish_alpine
            docker-image: i386/alpine:3.18
            artifact-name: spotdl-alpine-x86
            
    steps:
    - name: 1. Checkout del código
      uses: actions/checkout@v4

    # ¡El paso 2 original fue ELIMINADO!

    - name: 2. Compilación (Termux/Alpine) - Usando Docker
      # Este paso ahora es el 2 y ejecuta la lógica de compilación cruzada
      run: |
        TARGET_ARCH="${{ matrix.target-arch }}"
        TARGET_SYS="${{ matrix.target-system }}"
        DOCKER_IMAGE="${{ matrix.docker-image }}"
        ARTIFACT_NAME="${{ matrix.artifact-name }}"
        
        echo "Iniciando compilación para ARQUITECTURA: \$TARGET_ARCH en SISTEMA: \$TARGET_SYS"
        
        # 2.1. Crear el Script de Compilación Temporal
        # Este script se ejecuta dentro del contenedor Docker específico.
        cat > build_script.sh <<-EOF
        #!/bin/bash
        set -e
        
        # El directorio actual dentro del contenedor es /src
        
        if [[ "\$TARGET_SYS" == "termux" ]]; then
          echo "Ejecutando script de empaquetado Termux (simplicidad: solo archivos Python)"
          # NOTA: Para binarios reales, se recomienda usar el sistema de packaging de Termux.
          # Aquí, solo empaquetamos el código fuente de Python.
          apk update && apk add tar gzip # Asegurar que tar y gzip estén disponibles
          tar -czf "\$ARTIFACT_NAME.tar.gz" .
        
        elif [[ "\$TARGET_SYS" == "ish_alpine" ]]; then
          echo "Ejecutando script de compilación Alpine i386 (x86)"
          
          # 1. Instalar paquetes de desarrollo/Python en Alpine
          apk update
          apk add python3 py3-pip py3-dev gcc musl-dev openssl-dev # Dependencias básicas
          apk add ffmpeg # Instalar FFmpeg precompilado para i386
          
          # 2. Instalar herramientas Python
          pip install pyinstaller spotdl
          
          # 3. Crear el ejecutable con PyInstaller
          # PyInstaller creará un binario estático que incluye las dependencias y el binario FFmpeg
          pyinstaller --onefile spotdl/__main__.py -n spotdl
          
          # 4. Empaquetar
          mv dist/spotdl "\$ARTIFACT_NAME"
          tar -czf "\$ARTIFACT_NAME.tar.gz" "\$ARTIFACT_NAME"
        fi
        
        EOF
        
        # 2.2. Ejecutar el script dentro del contenedor
        docker run --rm \
          -v "$(pwd)":/src \
          -w /src \
          ${{ matrix.docker-image }} \
          /bin/sh /src/build_script.sh
          
    - name: 3. Subir Artefacto
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.artifact-name }}
        path: ${{ matrix.artifact-name }}.tar.gz
